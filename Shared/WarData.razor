@inject TornApiService ApiService
@inject TornStatsApiService StatsService
@inject BrowserStorageService BrowserStore
@inject FilterStateContainer FilterState
@inject ISnackbar Snackbar
@inject ILogger<WarData> Logger

<CascadingValue Value="@this">
    @if (_errorMessage is not null)
    {
        <ErrorState Title="Failed to load war details" Message="@_errorMessage" OnRetry="GetWarDetailsAsync" />
    }
    else
    {
    @if (!_initialized || UserFaction?.Ranked_Wars.Count != 0)
    {
        @ChildContent
    }
    else
    {
        <MudContainer Class="d-flex flex-column justify-center" MaxWidth="MaxWidth.Small" Style="height:100vh;">
            <EmptyState
                Icon="@Icons.Material.Filled.Shield"
                Title="No Active War"
                Message="Your faction is not currently in a ranked war. This dashboard will activate when a war begins."
                ActionText="Refresh Status"
                ActionIcon="@Icons.Material.Filled.Refresh"
                OnAction="GetWarDetailsAsync" />
        </MudContainer>
    }
    }
</CascadingValue>

@code {
    [Parameter] public RenderFragment? ChildContent { get; set; }

    [EditorRequired][Parameter] public EventCallback<string> OnWarEnded { get; set; }
    [EditorRequired][Parameter] public required ApplicationUser? CurrentUser { get; set; }
    [EditorRequired][Parameter] public required WarSession WarSession { get; set; }

    private const int MaxApiFailureRetries = 3;
    public bool Initialized => _initialized;
    public WarDataChangeTracker ChangeTracker { get; } = new();
    private bool _initialized;
    private string? _errorMessage;
    private PeriodicTimer Timer = new PeriodicTimer(TimeSpan.FromSeconds(5));

    public TornFaction? UserFaction { get; set; }
    public TornFaction? RivalFaction { get; set; }
    public Dictionary<int, Spy> Spies { get; set; } = [];

    protected override async Task OnInitializedAsync()
    {
        await GetWarDetailsAsync();

        await base.OnInitializedAsync();
    }

    private async Task GetWarDetailsAsync()
    {
        _errorMessage = null;
        var factionId = CurrentUser!.Faction.Faction_Id;

        var result = await ApiService.GetFactionAsync(factionId);

        if (result.IsFailure)
        {
            _errorMessage = result.Error;
            _initialized = true;
            StateHasChanged();
            return;
        }

        UserFaction = result.Value;

        if (UserFaction!.Ranked_Wars.Count == 0)
        {
            Timer.Dispose();
        }
        else
        {
            var war = UserFaction!.Ranked_Wars.First();

            WarSession.WarId = war.Key;
            WarSession.StartTime = war.Value.War.Start;

            var filterOptions = await BrowserStore.GetFilterOptionsAsync();

            if (filterOptions is not null)
            {
                if (filterOptions.WarId != war.Key)
                {
                    await BrowserStore.DeleteFilterOptionsAsync();
                }
                else
                {
                    WarSession.FactionTargets = filterOptions.Targets;
                    FilterState.FromOptions(filterOptions);
                }
            }

            await BrowserStore.SaveSessionAsync(WarSession);
        }

        _initialized = true;

        StateHasChanged();
    }

    public async Task MonitorWarProgressAsync()
    {
        var rivalId = UserFaction!.Ranked_Wars.First().Value.Factions.First(x => x.Key != UserFaction.Id).Key;

        var spiesResult = await StatsService.GetFactionSpiesAsync(rivalId);

        if (spiesResult.IsSuccess && spiesResult.Value is not null)
        {
            var newSpies = spiesResult.Value.Faction.Members.Values.ToDictionary(member => member.Id, member => member.Spy);
            if (!AreSpiesEqual(Spies, newSpies))
            {
                Spies = newSpies;
                ChangeTracker.NotifyChanged();
                StateHasChanged();
            }
        }

        int failureCount = 0;
        while (await Timer.WaitForNextTickAsync())
        {
            var result = await ApiService.GetFactionAsync(rivalId);

            if (result.IsSuccess)
            {
                failureCount = 0;
                var newFaction = result.Value;
                if (HasFactionChanged(RivalFaction, newFaction))
                {
                    RivalFaction = newFaction;
                    ChangeTracker.NotifyChanged();
                    StateHasChanged();
                }

                if (RivalFaction!.Ranked_Wars.First().Value.War.End > 0) Timer.Dispose();
            }
            else
            {
                failureCount++;
                Logger.LogWarning("Error fetching rival faction data: {Error}", result.Error);
                if (failureCount >= MaxApiFailureRetries)
                {
                    Snackbar.Add($"Failed to update war progress: {result.Error}", Severity.Error);
                }
            }
        }
    }

    private bool HasFactionChanged(TornFaction? oldF, TornFaction? newF)
    {
        if (ReferenceEquals(oldF, newF)) return false;
        if (oldF == null || newF == null) return true;

        if (oldF.Members.Count != newF.Members.Count) return true;

        foreach (var (id, oldMember) in oldF.Members)
        {
            if (!newF.Members.TryGetValue(id, out var newMember) || oldMember != newMember)
                return true;
        }

        if (oldF.Ranked_Wars.Count != newF.Ranked_Wars.Count) return true;
        foreach (var (warId, oldWar) in oldF.Ranked_Wars)
        {
            if (!newF.Ranked_Wars.TryGetValue(warId, out var newWar)) return true;
            if (oldWar.War != newWar.War) return true;

            if (oldWar.Factions.Count != newWar.Factions.Count) return true;
            foreach (var (fId, oldScore) in oldWar.Factions)
            {
                if (!newWar.Factions.TryGetValue(fId, out var newScore) || oldScore != newScore)
                    return true;
            }
        }

        return false;
    }

    private bool AreSpiesEqual(Dictionary<int, Spy> oldSpies, Dictionary<int, Spy> newSpies)
    {
        if (oldSpies.Count != newSpies.Count) return false;
        foreach (var (id, oldSpy) in oldSpies)
        {
            if (!newSpies.TryGetValue(id, out var newSpy) || oldSpy != newSpy)
                return false;
        }
        return true;
    }
}
